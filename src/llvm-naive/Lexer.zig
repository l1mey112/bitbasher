const std = @import("std");
const intern = @import("intern.zig");

const Allocator = std.mem.Allocator;
const ascii = std.ascii;
const StaticInternUnmanagedExtra = intern.StaticInternUnmanagedExtra;
const TokenMap = StaticInternUnmanagedExtra(Token.Kind, .{ .reserved_field_end = .declare });

const Lexer = @This();

b: [:0]const u8,
idx: usize,
token_map: TokenMap,
allocator: Allocator,

const Token = struct {
    kind: Kind,
    loc: Loc,

    const Kind = enum(usize) {
        err,
        eof,
        float,
        integer_type,
        label,

        // begin non-reserved
        declare,
        _,
    };

    pub const Loc = struct {
        start: usize,
        end: usize,

        fn slice(self: *const Loc, buffer: [:0]const u8) []const u8 {
            return buffer[self.start..self.end];
        }
    };
};

pub fn init(buffer: [:0]const u8, allocator: Allocator) Lexer {
    // skip the UTF-8 BOM if present
    return .{
        .b = buffer,
        .allocator = allocator,
        .idx = if (std.mem.startsWith(u8, buffer, "\xEF\xBB\xBF")) 3 else 0,
        .token_map = .init,
    };
}

pub fn deinit(self: *Lexer) void {
    self.token_map.deinit(self.allocator);
}

inline fn adv(self: *Lexer) ?u8 {
    const char = self.b[self.idx];
    self.idx += 1;

    if (self.idx >= self.b.len) {
        self.idx -= 1;
        return null;
    }

    return char;
}

pub fn next(self: *Lexer) !Token {
    while (true) {
        const err: Token = .{
            .kind = .err,
            .loc = .{ .start = self.idx, .end = self.idx + 1 }
        };
        
        if (self.adv()) |curr| switch (curr) {
            // [a-zA-Z_]
            '_', 'a'...'z', 'A'...'Z' => {
                return try self.lexIdentifier();
            },
            // Ignore whitespace
            0, ' ', '\t', '\n', '\r' => {
                continue;
            },
            // will not support floating point constants starting with `+`
            '+' => return err,
            else => return err,
        };
        return .{ .kind = .eof, .loc = .{ .start = self.b.len, .end = self.b.len } };
    }
}

fn isLabelChar(ch : u8) bool {
    return switch (ch) {
        '-', '$', '.', '_' => true,
        else => ascii.isAlphanumeric(ch),
    };
}

fn lexIdentifier(self: *Lexer) !Token {
    // "Lex a label, integer type, keyword, or hexadecimal integer constant."
    //    Label           [-a-zA-Z$._0-9]+:
    //    IntegerType     i[0-9]+
    //    Keyword         sdiv, float, ...
    //    HexIntConstant  [us]0x[0-9A-Fa-f]+

    var loc: Token.Loc = .{
        .start = self.idx - 1,
        .end = undefined,
    };

    // "Check for [us]0x[0-9A-Fa-f]+ which are Hexadecimal constant generated by
    // the CFE to avoid forcing it to deal with 64-bit numbers."

    // we can safely ignore these hex constants, as it is assumed the textual format
    // comes from "llvm-dis"

    if (self.b[self.idx - 1] == 'i' and ascii.isDigit(self.b[self.idx])) {
        const after_i = self.idx;
        var int_start = after_i;
        while (ascii.isDigit(self.b[int_start])) {
            int_start += 1;
        }

        if (!isLabelChar(self.b[int_start])) {
            loc.end = int_start;
            self.idx = int_start;
            // we don't validate bitwidth...
            return .{ .kind = .integer_type, .loc = loc };
        }
    }

    while (isLabelChar(self.b[self.idx])) {
        self.idx += 1;
    }

    // "When false (default), an identifier ending in ':' is a label token."
    // "When true, the ':' is treated as a separate token."
    // bool IgnoreColonInIdentifiers = false;

    // we can just assume the default, we don't need to be too compliant

    if (self.b[self.idx] == ':') {
        loc.end = self.idx + 1;
        return .{ .kind = .label, .loc = loc };
    }

    loc.end = self.idx;

    // catch all!
    const ident = try self.token_map.intern(self.allocator, loc.slice(self.b));
    return .{ .kind = ident, .loc = loc };
}

// fn lexPositive(self: *Lexer) Token {
//     var loc: Token.Loc = .{
//         .start = self.idx - 1,
//         .end = undefined,
//     };
    
//     // "If the letter after the negative is a number, this is probably not a label."
//     if (!ascii.isDigit(self.b[self.idx])) {
//         loc.end = self.idx + 1;
//         return .{ .kind = .err, .loc = loc };
//     }

//     // "Skip digits"
//     self.idx += 1;
//     while (ascii.isDigit(self.b[self.idx])) {
//         self.idx += 1;
//     }

//     // "At this point, we need a '.'."
//     if (self.b[self.idx] != '.') {
//         loc.end = self.idx + 1;
//         return .{ .kind = .err, .loc = loc };
//     }
//     self.idx += 1;

//     // "Skip over [0-9]*([eE][-+]?[0-9]+)?"
//     while (ascii.isDigit(self.b[self.idx])) {
//         self.idx += 1;
//     }

//     if (self.b[self.idx] == 'e' or self.b[self.idx] == 'E') {
//         if (ascii.isDigit(self.b[self.idx + 1]) or
//             (
//                 (self.b[self.idx + 1] == '-' or self.b[self.idx + 1] == '+') and
//                 ascii.isDigit(self.b[self.idx + 1])
//             )
//         ) {
//             self.idx += 2;
//             while (ascii.isDigit(self.b[self.idx])) {
//                 self.idx += 1;
//             }
//         }
//     }

//     loc.end = self.idx;
//     return .{
//         .kind = .float,
//         .loc = loc,
//     };
// }

const TestPiece = union(enum) {
    ident: Token.Kind,
    lit: [:0]const u8,
};

fn testPieces(buffer: [:0]const u8, pieces: []const TestPiece) !void {
    const allocator = std.testing.allocator;
    const expect = std.testing.expect;

    var lexer = Lexer.init(buffer, allocator);
    defer lexer.deinit();

    var i: usize = 0;
    while (true) {
        const tok = try lexer.next();

        switch (pieces[i]) {
            .ident => |kind| {
                try expect(tok.kind == kind);
            },
            .lit => |lit| {
                const kind = try lexer.token_map.intern(allocator, lit);
                try expect(tok.kind == kind);
            },
        }

        if (tok.kind == .eof) {
            break;
        }

        i += 1;
    }
}

test "ident" {
    const pieces = [_]TestPiece{
        .{ .ident = .declare },
        .{ .lit = "test" },
        .{ .ident = .integer_type },
        .{ .ident = .eof },
    };

    const buffer = "declare test\x00 i32";
    try testPieces(buffer, &pieces);
}
